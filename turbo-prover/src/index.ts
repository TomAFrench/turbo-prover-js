import { Crs } from '@noir-lang/barretenberg/dest/crs';
import { PooledFft } from '@noir-lang/barretenberg/dest/fft';
import { PooledPippenger } from '@noir-lang/barretenberg/dest/pippenger';
import { BarretenbergWasm, WorkerPool } from '@noir-lang/barretenberg/dest/wasm';
import { Prover } from '@noir-lang/barretenberg/dest/client_proofs/prover';
import { TurboProver } from './turbo_prover';
import { TurboVerifier } from './turbo_verifier';

export * from './turbo_prover';
export * from './turbo_verifier';

/**
 * Takes in a serialized `standard_format` Barretenberg circuit and returns a prover/verifier for this circuit.
 * This format can be generated from ACIR generated by the Noir compiler.
 *
 * `standard_format` is capable of representing any statement.
 *
 * @param serializedCircuit - The serialized Barretenberg circuit for which we want to prove against
 * @returns A tuple of a prover and verifier for the `serializedCircuit`.
 */
export async function setup_turbo_prover_and_verifier(
  serializedCircuit: Uint8Array,
): Promise<[TurboProver, TurboVerifier]> {
  const barretenberg = await BarretenbergWasm.new();

  const circSize = await getCircuitSize(barretenberg, serializedCircuit);

  const crs = await load_crs(circSize);

  const numWorkers = getNumCores();

  const wasm = await BarretenbergWasm.new();
  const workerPool = await WorkerPool.new(wasm, numWorkers);
  const pippenger = new PooledPippenger(workerPool);

  const fft = new PooledFft(workerPool);
  await fft.init(circSize);

  await pippenger.init(crs.getData());

  const prover = new Prover(workerPool.workers[0], pippenger, fft);

  const turboProver = new TurboProver(prover);
  await turboProver.initCircuitDefinition(serializedCircuit);
  const turboVerifier = new TurboVerifier();

  // Create proving key with a dummy CRS
  await turboProver.computeKey();
  // Create verifier key *and* patch proving key with the CRS
  await turboVerifier.computeKey(pippenger.pool[0], crs.getG2Data());

  return Promise.all([turboProver, turboVerifier]);
}

async function load_crs(circSize: number): Promise<Crs> {
  // We may need more elements in the SRS than the circuit size. In particular, we may need circSize +1
  // We add an offset here to account for that
  const offset = 1;

  const crs = new Crs(circSize + offset);
  await crs.download();

  return crs;
}

async function getCircuitSize(wasm: BarretenbergWasm, constraint_system: Uint8Array): Promise<number> {
  let pool = new WorkerPool();
  await pool.init(wasm.module, 8);
  let worker = pool.workers[0];

  const buf = Buffer.from(constraint_system);
  const mem = await worker.call('bbmalloc', buf.length);
  await worker.transferToHeap(buf, mem);

  const circSize = await worker.call('standard_example__get_circuit_size', mem);
  // FFT requires the circuit size to be a power of two.
  // If it is not, then we round it up to the nearest power of two
  return pow2ceil(circSize);
}

export async function create_proof(prover: TurboProver, witness_arr: Uint8Array): Promise<Uint8Array> {
  // computes the proof
  const proof = await prover.createProof(witness_arr);

  return proof;
}

export async function verify_proof(verifier: TurboVerifier, proof: Buffer): Promise<boolean> {
  const verified = await verifier.verifyProof(proof);
  return verified;
}

function getNumCores(): number {
  // TODO: The below comment was when we had this in a separate package
  //
  // Barretenberg.js uses navigator.hardwareConcurrency which is
  // only available in the desktop environment, not in js
  //
  // No need to find a polyfill for it, as our circuit is so small
  return 4;
}

// Rounds `v` up to the next power of two.
function pow2ceil(v: number): number {
  if (v > 0 && !(v & (v - 1))) return v;

  var p = 2;
  while ((v >>= 1)) {
    p <<= 1;
  }
  return p;
}
